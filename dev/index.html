<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MaterialReconstruction.jl · MaterialReconstruction.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">MaterialReconstruction.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">MaterialReconstruction.jl</a><ul class="internal"><li><a class="tocitem" href="#Cost-functions"><span>Cost functions</span></a></li><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#Samplers-and-modifiers"><span>Samplers and modifiers</span></a></li><li><a class="tocitem" href="#Cooldown-schedules"><span>Cooldown schedules</span></a></li><li><a class="tocitem" href="#Annealing"><span>Annealing</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">MaterialReconstruction.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">MaterialReconstruction.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MaterialReconstruction.jl"><a class="docs-heading-anchor" href="#MaterialReconstruction.jl">MaterialReconstruction.jl</a><a id="MaterialReconstruction.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MaterialReconstruction.jl" title="Permalink"></a></h1><p><code>MaterialReconstruction.jl</code> package can be used to recreate binary arrays (also called two-phase systems in this documentation) from a set of descriptors known as correlation functions using a technique called simulated annealing. It works in conjunction with packages <code>CorrelationFunctions.jl</code> and <code>CorrelationsTrackers.jl</code>.</p><p>This package is quite configurable which means you can decide which correlation functions to take into account, which cooldown schedule to use etc.</p><p>Look at this minimal example to see how <code>MaterialReconstruction.jl</code> can be used:</p><pre><code class="language-julia hljs">using CorrelationFunctions
using CorrelationTrackers
using MaterialReconstruction
using Images
using FileIO
using Random

Random.seed!(123)
# Load a binary array we want to reconstruct
array = load(&quot;images/value-noise.png&quot;) .|&gt; Bool
# Choose correlation functions we want to track (S2 for void phase, L2 for both phases)
functions = [S2Tracker(false), L2Tracker(false), L2Tracker(true)]
# Create an instance of CorrelationTracker type. Correlation functions are calculated
# with periodic boundary conditions.
target = CorrelationTracker(array; tracking = functions, periodic = true)

# Initialize an array to be reconstructed
system = CorrelationTracker(target |&gt; initialize_spheres, target)
# Create an instance of Furnace. T0 is an initial temperature
furnace = Furnace(system, target; T0 = 2e-5)
# Choose a cost function.
# (More about Čapek cost function in the section &quot;Cost functions&quot;)
cost = čapek_cost(system, target, 0.4)
# Choose a modifier (more in the section &quot;Samplers and modifiers&quot;)
modifier = Flipper(InterfaceSampler())
# Choose a cooldown schedule (more in the section &quot;Cooldown schedules&quot;)
cooldown = aarts_korst_cooldown(n = 100, λ = 0.01)

# Measure initial value of the cost function
cost1 = cost(target, system)

# This is a kludge used to work around impossibility of reassigning a variable
# in the loop in examples generated by Documenter.jl
function annealing_step!(f)
    f[] = annealing_step(f[];
                         cost     = cost,
                         modifier = modifier,
                         cooldown = cooldown)
end

# Run 5000 annealing steps. Usually you have to repeat this loop a few million times.
f = Ref(furnace)
for i in 1:5000
    annealing_step!(f)
end

# Measure final value of the cost function
cost2 = cost(target, system)
cost1, cost2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.08031552774628573, 0.05330782954198182)</code></pre><p>As you see, the cost function decreases after 5000 iterations of the process. More illustrative examples are in the section <a href="index.html#Examples">Examples</a>. Each aspect of <code>MaterialReconstruction.jl</code> API is described in a dedicated section.</p><h2 id="Cost-functions"><a class="docs-heading-anchor" href="#Cost-functions">Cost functions</a><a id="Cost-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-functions" title="Permalink"></a></h2><p>Cost functions are the functions which are minimized during simulated annealing. Usually, we have two binary arrays, one of them is fixed (the target array) and the other is changed during annealing. An annealing process stops when the value of the cost function becomes small enough which means two arrays are &quot;similar&quot; to each other. A cost function takes two <code>CorrelationTracker</code> objects (which are our arrays + a set of correlation functions calculated for those arrays) and returns a real number which specifies how similar those arrays are. Usually, this similarity is measured by comparing the values of correlation functions. The following cost functions are defined in this package:</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.euclid_mean" href="#MaterialReconstruction.euclid_mean"><code>MaterialReconstruction.euclid_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euclid_mean(data1 :: CorrelationData, data2 :: CorrelationData)
euclid_mean(data1 :: AbstractArray, data2 :: AbstractArray)</code></pre><p>Calculate squared euclidean distance between values of two correlation functions (represented as <code>CorrelationData</code> object) or two systems (represented as <code>AbstractArray</code> object). The values are averaged along all directions before calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cost.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.euclid_directional" href="#MaterialReconstruction.euclid_directional"><code>MaterialReconstruction.euclid_directional</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euclid_directional(data1 :: CorrelationData, data2 :: CorrelationData)
euclid_directional(data1 :: AbstractArray, data2 :: AbstractArray)</code></pre><p>Calculate squared euclidean distance between values of two correlation functions (represented as <code>CorrelationData</code> object) or two systems (represented as <code>AbstractArray</code> object). The values calculated along different directions are not averaged and treated separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cost.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.euclid_mean_weighted" href="#MaterialReconstruction.euclid_mean_weighted"><code>MaterialReconstruction.euclid_mean_weighted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euclid_mean_weighted(data1 :: AbstractArray, data2 :: AbstractArray)</code></pre><p>Calculate squared euclidean distance between values of two correlation functions (represented as <code>CorrelationData</code> object) or two systems (represented as <code>AbstractArray</code> object). The values are averaged along all directions before calculation.</p><p>Each correlation function has its own weight as described in Kirill M. Gerke and Marina V. Karsanina 2015 EPL 111 56002</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cost.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.euclid_directional_weighted" href="#MaterialReconstruction.euclid_directional_weighted"><code>MaterialReconstruction.euclid_directional_weighted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euclid_directional_weighted(data1 :: AbstractArray, data2 :: AbstractArray)</code></pre><p>Calculate squared euclidean distance between values of two correlation functions (represented as <code>CorrelationData</code> object) or two systems (represented as <code>AbstractArray</code> object). The values calculated along different directions are not averaged and treated separately.</p><p>Each correlation function has its own weight as described in Kirill M. Gerke and Marina V. Karsanina 2015 EPL 111 56002</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cost.jl#L90-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.čapek_cost" href="#MaterialReconstruction.čapek_cost"><code>MaterialReconstruction.čapek_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">čapek_cost(data1 :: AbstractArray, data2 :: AbstractArray, η = 0.6)</code></pre><p>Returns a function which calculates the cost based on two-point correlation function for void phase  and lineal-path function for solid and void phases where contribution of the latter increases with time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cost.jl#L156-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.generalized_čapek_cost" href="#MaterialReconstruction.generalized_čapek_cost"><code>MaterialReconstruction.generalized_čapek_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generalized_čapek_cost(tracker1, tracker2, dict)</code></pre><p>Returns a function which calculates the cost based on two-point and lineal-path functions for solid phase and any other functions present in <code>keys(dict)</code>. <code>dict</code> is a dictionary which includes key-value pairs <code>AbstractTracker =&gt; Float64</code>. Values of <code>dict</code> must be in range <code>[0, 1]</code>. They control an initial contribution of the corresponding correlation function. The smaller these values are the smaller is the initial contribution. Contributions of all correlation functions equivalizes when the cost function becomes small.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cost.jl#L112-L123">source</a></section></article><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><p>Before running simulated annealing, you must begin with some initial state. The following functions serve for creation of such state. An optional <code>shape</code> argument can be given to all of these functions to initialize array with a shape which is different from <code>target</code>&#39;s.</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.initialize_random" href="#MaterialReconstruction.initialize_random"><code>MaterialReconstruction.initialize_random</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize_random(target :: AbstractArray[, shape])</code></pre><p>Initialize a system for the annealing procedure. The system is to be filled with random data in such a way that the porosity of the <code>target</code> is preserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/initialization.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.initialize_spheres" href="#MaterialReconstruction.initialize_spheres"><code>MaterialReconstruction.initialize_spheres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize_spheres(target :: AbstractArray[, shape])</code></pre><p>Initialize a system for the annealing procedure. The system is to be filled with random spheres so its two-point correlation function for the void phase is as close as possible to the <code>target</code>&#39;s one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/initialization.jl#L40-L46">source</a></section></article><h2 id="Samplers-and-modifiers"><a class="docs-heading-anchor" href="#Samplers-and-modifiers">Samplers and modifiers</a><a id="Samplers-and-modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers-and-modifiers" title="Permalink"></a></h2><p>Simulated annealing works by taking a random sample (or a few) from an array to be reconstructed, modifying it (them) and either accepting the modification or rejecting it. You can choose how exactly sampling and modification steps are performed by choosing one of existent <code>AbstractModifier</code> and <code>AbstractSampler</code> types or writing your own.</p><h3 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h3><p>Samplers are subtypes of <code>AbstractSampler</code>. They define how exactly a sample to be modified is chosen. There are three samplers in this package:</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.UniformSampler" href="#MaterialReconstruction.UniformSampler"><code>MaterialReconstruction.UniformSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformSampler()</code></pre><p>Create a sampler which picks samples randomly with uniform distribution.</p><p>See also: <a href="index.html#MaterialReconstruction.AbstractSampler"><code>AbstractSampler</code></a>, <a href="index.html#MaterialReconstruction.InterfaceSampler"><code>InterfaceSampler</code></a>, <a href="index.html#MaterialReconstruction.DPNSampler"><code>DPNSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.InterfaceSampler" href="#MaterialReconstruction.InterfaceSampler"><code>MaterialReconstruction.InterfaceSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InterfaceSampler()</code></pre><p>Create a sampler which picks samples randomly from an interface between phases.</p><p>See also: <a href="index.html#MaterialReconstruction.UniformSampler"><code>UniformSampler</code></a>, <a href="index.html#MaterialReconstruction.AbstractSampler"><code>AbstractSampler</code></a>, <a href="index.html#MaterialReconstruction.DPNSampler"><code>DPNSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.DPNSampler" href="#MaterialReconstruction.DPNSampler"><code>MaterialReconstruction.DPNSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DPNSampler(array, α)</code></pre><p>Create a sampler which picks a random sample with <span>$n$</span> different phase neighbors with probability  <span>$p \propto \alpha^n N(n)$</span> where <span>$N(n)$</span> is a number of pixels having <span>$n$</span> different phase neighbors in the system.</p><p>See also: <a href="index.html#MaterialReconstruction.UniformSampler"><code>UniformSampler</code></a>, <a href="index.html#MaterialReconstruction.InterfaceSampler"><code>InterfaceSampler</code></a>, <a href="index.html#MaterialReconstruction.AbstractSampler"><code>AbstractSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L40-L49">source</a></section></article><p>You can also write your own sampler type which must be a subtype of <code>AbstractSampler</code> and implement the following interface:</p><table><tr><th style="text-align: right">Function name</th><th style="text-align: right">Optional?</th><th style="text-align: right">Default definition</th></tr><tr><td style="text-align: right"><code>update_pre!</code></td><td style="text-align: right">Yes</td><td style="text-align: right"><code>nothing</code></td></tr><tr><td style="text-align: right"><code>update_post!</code></td><td style="text-align: right">Yes</td><td style="text-align: right"><code>nothing</code></td></tr><tr><td style="text-align: right"><code>sample</code></td><td style="text-align: right">No</td><td style="text-align: right"></td></tr></table><p>The first two functions must only be implemented if you sampler has some state which must be updated when a reconstructed array is changed.</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.AbstractSampler" href="#MaterialReconstruction.AbstractSampler"><code>MaterialReconstruction.AbstractSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AbstractSampler</code> type is responsible for picking samples (voxels or pixels) during annealing process.</p><p>See also: <a href="index.html#MaterialReconstruction.UniformSampler"><code>UniformSampler</code></a>, <a href="index.html#MaterialReconstruction.InterfaceSampler"><code>InterfaceSampler</code></a>, <a href="index.html#MaterialReconstruction.DPNSampler"><code>DPNSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.update_pre!" href="#MaterialReconstruction.update_pre!"><code>MaterialReconstruction.update_pre!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_pre!(array, index, sampler)</code></pre><p>Update the state of sampler before the value <code>array[index]</code> is changed. Should only be implemented for stateful samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.update_post!" href="#MaterialReconstruction.update_post!"><code>MaterialReconstruction.update_post!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_post!(array, index, sampler)</code></pre><p>Update the state of sampler after the value <code>array[index]</code> is changed. Should only be implemented for stateful samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.sample" href="#MaterialReconstruction.sample"><code>MaterialReconstruction.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(array, sampler)</code></pre><p>Get a random sample from the array. This function must return an index, e.g. <code>CartesianIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L103-L108">source</a></section></article><h3 id="Modifiers"><a class="docs-heading-anchor" href="#Modifiers">Modifiers</a><a id="Modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Modifiers" title="Permalink"></a></h3><p>Modifier types are subtypes of <code>AbstractModifier</code>. They define how to modify samples returned from <code>sample</code> function. <code>MaterialReconstruction.jl</code> provides two modifier types:</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.Flipper" href="#MaterialReconstruction.Flipper"><code>MaterialReconstruction.Flipper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flipper(sampler)</code></pre><p>Create a modifier which changes phase of a sample taken from a binary array.</p><p>See also: <a href="index.html#MaterialReconstruction.AbstractModifier"><code>AbstractModifier</code></a>, <a href="index.html#MaterialReconstruction.Swapper"><code>Swapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.Swapper" href="#MaterialReconstruction.Swapper"><code>MaterialReconstruction.Swapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Swapper(sampler)</code></pre><p>Create a modifier which takes two samples having different phases and swaps phases of these two samples.</p><p>See also: <a href="index.html#MaterialReconstruction.Flipper"><code>Flipper</code></a>, <a href="index.html#MaterialReconstruction.AbstractModifier"><code>AbstractModifier</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L73-L80">source</a></section></article><p>You can also implement your own modifier type subtyping <code>AbstractModifier</code> and implementing two methods: <code>modify!</code> and <code>reject!</code>.</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.AbstractModifier" href="#MaterialReconstruction.AbstractModifier"><code>MaterialReconstruction.AbstractModifier</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AbstractModifier</code> type is responsible for how configuration update steps are performed during an annealing process.</p><p>See also: <a href="index.html#MaterialReconstruction.Flipper"><code>Flipper</code></a>, <a href="index.html#MaterialReconstruction.Swapper"><code>Swapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.modify!" href="#MaterialReconstruction.modify!"><code>MaterialReconstruction.modify!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify!(array, modifier)</code></pre><p>Randomly modify the array. This function must return a state used in <code>reject!</code> to bring the array to a previous state if this modification is rejected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.reject!" href="#MaterialReconstruction.reject!"><code>MaterialReconstruction.reject!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reject!(array, modifier, state)</code></pre><p>Bring the array back to the previous state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/modifiers.jl#L136-L140">source</a></section></article><h2 id="Cooldown-schedules"><a class="docs-heading-anchor" href="#Cooldown-schedules">Cooldown schedules</a><a id="Cooldown-schedules-1"></a><a class="docs-heading-anchor-permalink" href="#Cooldown-schedules" title="Permalink"></a></h2><p>When a modification to a reconstructed array results in increase of the cost function a decision to either accept or reject that modification is taken according to the parameter called &quot;temperature&quot;. The higher the temperature the higher the probability that the change is accepted. After each accepted modification the temperature decreases according to the cooldown schedule. There are three predefined schedules in <code>MaterialReconstruction.jl</code>:</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.exponential_cooldown" href="#MaterialReconstruction.exponential_cooldown"><code>MaterialReconstruction.exponential_cooldown</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exponential_cooldown(λ :: Float64)</code></pre><p>Create an exponential cooldown schedule. Temperature on step <span>$n + 1$</span> is calculated as <span>$T_{n + 1} = \lambda T_{n}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cooldown.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.aarts_korst_cooldown" href="#MaterialReconstruction.aarts_korst_cooldown"><code>MaterialReconstruction.aarts_korst_cooldown</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aarts_korst_cooldown(;n = 15, λ = 0.01)</code></pre><p>Make the Aarts-Korst cooldown schedule. The temperature decreases each <code>n</code> steps of annealing algorithm. The higer <code>λ</code> is the faster decreases the temperature.</p><p>For more information, see Aarts, E.H.L. and Korst, J.H.M. (1989) Simulated Annealing and Boltzmann Machines: A Stochastic Approach to Combinatorial Optimization and Neural Computing. John Wiley &amp; Sons, Chichester.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cooldown.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.frost_heineman_cooldown" href="#MaterialReconstruction.frost_heineman_cooldown"><code>MaterialReconstruction.frost_heineman_cooldown</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frost_heineman_cooldown(;n = 250, λ = 0.01)</code></pre><p>Make the Frost-Heineman cooldown schedule. The temperature decreases each <code>n</code> steps of annealing algorithm or until some &quot;target&quot; energy is reached. The target energy is based on standard deviation of the cost function and a parameter <code>λ</code>.</p><p>For more information, see R. Frost, P. Heineman &quot;Simulated Annealing: A Heuristic for Parallel Stochastic Optimization&quot; (1997)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/cooldown.jl#L46-L56">source</a></section></article><h2 id="Annealing"><a class="docs-heading-anchor" href="#Annealing">Annealing</a><a id="Annealing-1"></a><a class="docs-heading-anchor-permalink" href="#Annealing" title="Permalink"></a></h2><p>When an array you wish to reconstruct is initialized, a cooldown schedule, a cost function and a modifier are chosen, you must create an object of type <code>Furnace</code> and run <code>annealing_step</code> function many times until the cost function returns a value small enough to consider that two arrays have the same values of correlation functions.</p><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.Furnace" href="#MaterialReconstruction.Furnace"><code>MaterialReconstruction.Furnace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Furnace(system :: AbstractArray, target :: AbstractArray; T0)</code></pre><p>Initialize a furnace (an object which is used in annealing process). <code>system</code> is an array being reconstructed to be similar to <code>target</code>. <code>T0</code> is an initial temperature of a furnace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/furnace.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaterialReconstruction.annealing_step" href="#MaterialReconstruction.annealing_step"><code>MaterialReconstruction.annealing_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">annealing_step(furnace[; cooldown][, cost][, modifier])</code></pre><p>Perform one step of annealing procedure. <code>cooldown</code> is a function defining how fast the furnace will lose temperature. <code>cost</code> determines a function we want to minimize. <code>modifier</code> determines which small modifications are made to the system during the step.</p><p><strong>NB:</strong> The updated state of the annealing process is returned by this function as a new <code>Furnace</code> object. Do not discard it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fatimp/MaterialReconstruction.jl/blob/84aaae50ab9af7b6ec85726550d726f4bcf3a90a/src/annealing.jl#L1-L11">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>All following examples are reconstructed from two-point and lineal-path functions calculated in axial and diagonal directions.</p><h3 id="Value-noise-(small-details)"><a class="docs-heading-anchor" href="#Value-noise-(small-details)">Value noise (small details)</a><a id="Value-noise-(small-details)-1"></a><a class="docs-heading-anchor-permalink" href="#Value-noise-(small-details)" title="Permalink"></a></h3><table><tr><th style="text-align: right">Original</th><th style="text-align: right">Reconstruction</th></tr><tr><td style="text-align: right"><img src="images/value-noise2.png" alt/></td><td style="text-align: right"><img src="images/value-noise2-recon-diag-s2l2.png" alt/></td></tr></table><h3 id="Value-noise-(big-details)"><a class="docs-heading-anchor" href="#Value-noise-(big-details)">Value noise (big details)</a><a id="Value-noise-(big-details)-1"></a><a class="docs-heading-anchor-permalink" href="#Value-noise-(big-details)" title="Permalink"></a></h3><table><tr><th style="text-align: right">Original</th><th style="text-align: right">Reconstruction</th></tr><tr><td style="text-align: right"><img src="images/value-noise3.png" alt/></td><td style="text-align: right"><img src="images/value-noise3-recon-diag-s2l2.png" alt/></td></tr></table><h3 id="Checkboard"><a class="docs-heading-anchor" href="#Checkboard">Checkboard</a><a id="Checkboard-1"></a><a class="docs-heading-anchor-permalink" href="#Checkboard" title="Permalink"></a></h3><table><tr><th style="text-align: right">Original</th><th style="text-align: right">Reconstruction</th></tr><tr><td style="text-align: right"><img src="images/checkboard.png" alt/></td><td style="text-align: right"><img src="images/checkboard-recon-diag-s2l2.png" alt/></td></tr></table><h3 id="Sample-from-digitalrocksportal.org"><a class="docs-heading-anchor" href="#Sample-from-digitalrocksportal.org">Sample from digitalrocksportal.org</a><a id="Sample-from-digitalrocksportal.org-1"></a><a class="docs-heading-anchor-permalink" href="#Sample-from-digitalrocksportal.org" title="Permalink"></a></h3><table><tr><th style="text-align: right">Original</th><th style="text-align: right">Reconstruction</th></tr><tr><td style="text-align: right"><img src="images/image1.png" alt/></td><td style="text-align: right"><img src="images/image1-recon-diag-s2l2.png" alt/></td></tr></table></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 31 August 2022 15:32">Wednesday 31 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
