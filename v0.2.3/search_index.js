var documenterSearchIndex = {"docs":
[{"location":"index.html#MaterialReconstruction.jl","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"MaterialReconstruction.jl package can be used to recreate binary arrays (also called two-phase systems in this documentation) from a set of descriptors known as correlation functions using a technique called simulated annealing. It works in conjunction with packages CorrelationFunctions.jl and CorrelationsTrackers.jl.","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"This package is quite configurable which means you can decide which correlation functions to take into account, which cooldown schedule to use etc.","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Look at this minimal example to see how MaterialReconstruction.jl can be used:","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"using CorrelationFunctions\nusing CorrelationTrackers\nusing MaterialReconstruction\nusing Images\nusing FileIO\nusing Random\n\nRandom.seed!(123)\n# Load a binary array we want to reconstruct\narray = load(\"images/value-noise.png\") .|> Bool\n# Choose correlation functions we want to track (S2 for void phase, L2 for both phases)\nfunctions = [S2Tracker(false), L2Tracker(false), L2Tracker(true)]\n# Create an instance of CorrelationTracker type. Correlation functions are calculated\n# with periodic boundary conditions.\ntarget = CorrelationTracker(array; tracking = functions, periodic = true)\n\n# Initialize an array to be reconstructed\nsystem = CorrelationTracker(target |> initialize_spheres, target)\n# Create an instance of Furnace. T0 is an initial temperature\nfurnace = Furnace(system, target; T0 = 2e-5)\n# Choose a cost function.\n# (More about Čapek cost function in the section \"Cost functions\")\ncost = čapek_cost(system, target, 0.4)\n# Choose a modifier (more in the section \"Samplers and modifiers\")\nmodifier = Flipper(InterfaceSampler())\n# Choose a cooldown schedule (more in the section \"Cooldown schedules\")\ncooldown = aarts_korst_cooldown(n = 100, λ = 0.01)\n\n# Measure initial value of the cost function\ncost1 = cost(target, system)\n\n# This is a kludge used to work around impossibility of reassigning a variable\n# in the loop in examples generated by Documenter.jl\nfunction annealing_step!(f)\n    f[] = annealing_step(f[];\n                         cost     = cost,\n                         modifier = modifier,\n                         cooldown = cooldown)\nend\n\n# Run 5000 annealing steps. Usually you have to repeat this loop a few million times.\nf = Ref(furnace)\nfor i in 1:5000\n    annealing_step!(f)\nend\n\n# Measure final value of the cost function\ncost2 = cost(target, system)\ncost1, cost2","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"As you see, the cost function decreases after 5000 iterations of the process. More illustrative examples are in the section Examples. Each aspect of MaterialReconstruction.jl API is described in a dedicated section.","category":"page"},{"location":"index.html#Cost-functions","page":"MaterialReconstruction.jl","title":"Cost functions","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Cost functions are the functions which are minimized during simulated annealing. Usually, we have two binary arrays, one of them is fixed (the target array) and the other is changed during annealing. An annealing process stops when the value of the cost function becomes small enough which means two arrays are \"similar\" to each other. A cost function takes two CorrelationTracker objects (which are our arrays + a set of correlation functions calculated for those arrays) and returns a real number which specifies how similar those arrays are. Usually, this similarity is measured by comparing the values of correlation functions. The following cost functions are defined in this package:","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"euclid_mean\neuclid_directional\neuclid_mean_weighted\neuclid_directional_weighted\nčapek_cost\ngeneralized_čapek_cost","category":"page"},{"location":"index.html#MaterialReconstruction.euclid_mean","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.euclid_mean","text":"euclid_mean(data1 :: CorrelationData, data2 :: CorrelationData)\neuclid_mean(data1 :: AbstractArray, data2 :: AbstractArray)\n\nCalculate squared euclidean distance between values of two correlation functions (represented as CorrelationData object) or two systems (represented as AbstractArray object). The values are averaged along all directions before calculation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.euclid_directional","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.euclid_directional","text":"euclid_directional(data1 :: CorrelationData, data2 :: CorrelationData)\neuclid_directional(data1 :: AbstractArray, data2 :: AbstractArray)\n\nCalculate squared euclidean distance between values of two correlation functions (represented as CorrelationData object) or two systems (represented as AbstractArray object). The values calculated along different directions are not averaged and treated separately.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.euclid_mean_weighted","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.euclid_mean_weighted","text":"euclid_mean_weighted(data1 :: AbstractArray, data2 :: AbstractArray)\n\nCalculate squared euclidean distance between values of two correlation functions (represented as CorrelationData object) or two systems (represented as AbstractArray object). The values are averaged along all directions before calculation.\n\nEach correlation function has its own weight as described in Kirill M. Gerke and Marina V. Karsanina 2015 EPL 111 56002\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.euclid_directional_weighted","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.euclid_directional_weighted","text":"euclid_directional_weighted(data1 :: AbstractArray, data2 :: AbstractArray)\n\nCalculate squared euclidean distance between values of two correlation functions (represented as CorrelationData object) or two systems (represented as AbstractArray object). The values calculated along different directions are not averaged and treated separately.\n\nEach correlation function has its own weight as described in Kirill M. Gerke and Marina V. Karsanina 2015 EPL 111 56002\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.čapek_cost","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.čapek_cost","text":"čapek_cost(data1 :: AbstractArray, data2 :: AbstractArray, η = 0.6)\n\nReturns a function which calculates the cost based on two-point correlation function for void phase  and lineal-path function for solid and void phases where contribution of the latter increases with time.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.generalized_čapek_cost","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.generalized_čapek_cost","text":"generalized_čapek_cost(tracker1, tracker2, dict)\n\nReturns a function which calculates the cost based on two-point and lineal-path functions for solid phase and any other functions present in keys(dict). dict is a dictionary which includes key-value pairs AbstractTracker => Float64. Values of dict must be in range [0, 1]. They control an initial contribution of the corresponding correlation function. The smaller these values are the smaller is the initial contribution. Contributions of all correlation functions equivalizes when the cost function becomes small.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Initialization","page":"MaterialReconstruction.jl","title":"Initialization","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Before running simulated annealing, you must begin with some initial state. The following functions serve for creation of such state. An optional shape argument can be given to all of these functions to initialize array with a shape which is different from target's.","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"initialize_random\ninitialize_spheres","category":"page"},{"location":"index.html#MaterialReconstruction.initialize_random","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.initialize_random","text":"initialize_random(target :: AbstractArray[, shape])\n\nInitialize a system for the annealing procedure. The system is to be filled with random data in such a way that the porosity of the target is preserved.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.initialize_spheres","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.initialize_spheres","text":"initialize_spheres(target :: AbstractArray[, shape])\n\nInitialize a system for the annealing procedure. The system is to be filled with random spheres so its two-point correlation function for the void phase is as close as possible to the target's one.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Samplers-and-modifiers","page":"MaterialReconstruction.jl","title":"Samplers and modifiers","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Simulated annealing works by taking a random sample (or a few) from an array to be reconstructed, modifying it (them) and either accepting the modification or rejecting it. You can choose how exactly sampling and modification steps are performed by choosing one of existent AbstractModifier and AbstractSampler types or writing your own.","category":"page"},{"location":"index.html#Samplers","page":"MaterialReconstruction.jl","title":"Samplers","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Samplers are subtypes of AbstractSampler. They define how exactly a sample to be modified is chosen. There are three samplers in this package:","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"UniformSampler\nInterfaceSampler\nDPNSampler","category":"page"},{"location":"index.html#MaterialReconstruction.UniformSampler","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.UniformSampler","text":"UniformSampler()\n\nCreate a sampler which picks samples randomly with uniform distribution.\n\nSee also: AbstractSampler, InterfaceSampler, DPNSampler.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialReconstruction.InterfaceSampler","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.InterfaceSampler","text":"InterfaceSampler()\n\nCreate a sampler which picks samples randomly from an interface between phases.\n\nSee also: UniformSampler, AbstractSampler, DPNSampler.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialReconstruction.DPNSampler","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.DPNSampler","text":"DPNSampler(array, α)\n\nCreate a sampler which picks a random sample with n different phase neighbors with probability  p propto alpha^n N(n) where N(n) is a number of pixels having n different phase neighbors in the system.\n\nSee also: UniformSampler, InterfaceSampler, AbstractSampler.\n\n\n\n\n\n","category":"type"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"You can also write your own sampler type which must be a subtype of AbstractSampler and implement the following interface:","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Function name Optional? Default definition\nupdate_pre! Yes nothing\nupdate_post! Yes nothing\nsample No ","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"The first two functions must only be implemented if you sampler has some state which must be updated when a reconstructed array is changed.","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"AbstractSampler\nupdate_pre!\nupdate_post!\nsample","category":"page"},{"location":"index.html#MaterialReconstruction.AbstractSampler","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.AbstractSampler","text":"AbstractSampler type is responsible for picking samples (voxels or pixels) during annealing process.\n\nSee also: UniformSampler, InterfaceSampler, DPNSampler.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialReconstruction.update_pre!","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.update_pre!","text":"update_pre!(array, index, sampler)\n\nUpdate the state of sampler before the value array[index] is changed. Should only be implemented for stateful samplers.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.update_post!","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.update_post!","text":"update_post!(array, index, sampler)\n\nUpdate the state of sampler after the value array[index] is changed. Should only be implemented for stateful samplers.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.sample","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.sample","text":"sample(array, sampler)\n\nGet a random sample from the array. This function must return an index, e.g. CartesianIndex.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Modifiers","page":"MaterialReconstruction.jl","title":"Modifiers","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Modifier types are subtypes of AbstractModifier. They define how to modify samples returned from sample function. MaterialReconstruction.jl provides two modifier types:","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Flipper\nSwapper","category":"page"},{"location":"index.html#MaterialReconstruction.Flipper","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.Flipper","text":"Flipper(sampler)\n\nCreate a modifier which changes phase of a sample taken from a binary array.\n\nSee also: AbstractModifier, Swapper.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialReconstruction.Swapper","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.Swapper","text":"Swapper(sampler)\n\nCreate a modifier which takes two samples having different phases and swaps phases of these two samples.\n\nSee also: Flipper, AbstractModifier.\n\n\n\n\n\n","category":"type"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"You can also implement your own modifier type subtyping AbstractModifier and implementing two methods: modify! and reject!.","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"AbstractModifier\nmodify!\nreject!","category":"page"},{"location":"index.html#MaterialReconstruction.AbstractModifier","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.AbstractModifier","text":"AbstractModifier type is responsible for how configuration update steps are performed during an annealing process.\n\nSee also: Flipper, Swapper.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialReconstruction.modify!","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.modify!","text":"modify!(array, modifier)\n\nRandomly modify the array. This function must return a state used in reject! to bring the array to a previous state if this modification is rejected.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.reject!","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.reject!","text":"reject!(array, modifier, state)\n\nBring the array back to the previous state.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Cooldown-schedules","page":"MaterialReconstruction.jl","title":"Cooldown schedules","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"When a modification to a reconstructed array results in increase of the cost function a decision to either accept or reject that modification is taken according to the parameter called \"temperature\". The higher the temperature the higher the probability that the change is accepted. After each accepted modification the temperature decreases according to the cooldown schedule. There are three predefined schedules in MaterialReconstruction.jl:","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"exponential_cooldown\naarts_korst_cooldown\nfrost_heineman_cooldown","category":"page"},{"location":"index.html#MaterialReconstruction.exponential_cooldown","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.exponential_cooldown","text":"exponential_cooldown(λ :: Float64)\n\nCreate an exponential cooldown schedule. Temperature on step n + 1 is calculated as T_n + 1 = lambda T_n.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.aarts_korst_cooldown","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.aarts_korst_cooldown","text":"aarts_korst_cooldown(;n = 15, λ = 0.01)\n\nMake the Aarts-Korst cooldown schedule. The temperature decreases each n steps of annealing algorithm. The higer λ is the faster decreases the temperature.\n\nFor more information, see Aarts, E.H.L. and Korst, J.H.M. (1989) Simulated Annealing and Boltzmann Machines: A Stochastic Approach to Combinatorial Optimization and Neural Computing. John Wiley & Sons, Chichester.\n\n\n\n\n\n","category":"function"},{"location":"index.html#MaterialReconstruction.frost_heineman_cooldown","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.frost_heineman_cooldown","text":"frost_heineman_cooldown(;n = 250, λ = 0.01)\n\nMake the Frost-Heineman cooldown schedule. The temperature decreases each n steps of annealing algorithm or until some \"target\" energy is reached. The target energy is based on standard deviation of the cost function and a parameter λ.\n\nFor more information, see R. Frost, P. Heineman \"Simulated Annealing: A Heuristic for Parallel Stochastic Optimization\" (1997)\n\n\n\n\n\n","category":"function"},{"location":"index.html#Annealing","page":"MaterialReconstruction.jl","title":"Annealing","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"When an array you wish to reconstruct is initialized, a cooldown schedule, a cost function and a modifier are chosen, you must create an object of type Furnace and run annealing_step function many times until the cost function returns a value small enough to consider that two arrays have the same values of correlation functions.","category":"page"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Furnace\nannealing_step","category":"page"},{"location":"index.html#MaterialReconstruction.Furnace","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.Furnace","text":"Furnace(system :: AbstractArray, target :: AbstractArray; T0)\n\nInitialize a furnace (an object which is used in annealing process). system is an array being reconstructed to be similar to target. T0 is an initial temperature of a furnace.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialReconstruction.annealing_step","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.annealing_step","text":"annealing_step(furnace[; cooldown][, cost][, modifier])\n\nPerform one step of annealing procedure. cooldown is a function defining how fast the furnace will lose temperature. cost determines a function we want to minimize. modifier determines which small modifications are made to the system during the step.\n\nNB: The updated state of the annealing process is returned by this function as a new Furnace object. Do not discard it.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Examples","page":"MaterialReconstruction.jl","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"All following examples are reconstructed from two-point and lineal-path functions calculated in axial and diagonal directions.","category":"page"},{"location":"index.html#Value-noise-(small-details)","page":"MaterialReconstruction.jl","title":"Value noise (small details)","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Original Reconstruction\n(Image: ) (Image: )","category":"page"},{"location":"index.html#Value-noise-(big-details)","page":"MaterialReconstruction.jl","title":"Value noise (big details)","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Original Reconstruction\n(Image: ) (Image: )","category":"page"},{"location":"index.html#Checkboard","page":"MaterialReconstruction.jl","title":"Checkboard","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Original Reconstruction\n(Image: ) (Image: )","category":"page"},{"location":"index.html#Sample-from-digitalrocksportal.org","page":"MaterialReconstruction.jl","title":"Sample from digitalrocksportal.org","text":"","category":"section"},{"location":"index.html","page":"MaterialReconstruction.jl","title":"MaterialReconstruction.jl","text":"Original Reconstruction\n(Image: ) (Image: )","category":"page"}]
}
